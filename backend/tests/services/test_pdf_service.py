"""
Tests for PDF Service (F-008: PDF Processing)

Tests cover:
- Scenario 1: Successful PDF text extraction
- Scenario 2: PDF file size validation (10MB limit)
- Scenario 3: PDF page count validation (50 pages limit)
- Scenario 4: Invalid PDF handling
- Scenario 5: Empty/scanned PDF handling
- Scenario 6: Process PDF for learning (integration with Claude)
- Scenario 7: Multi-language PDF processing (Spanish/English)
"""

import io
from unittest.mock import AsyncMock, Mock, patch

import pdfplumber
import pytest

from app.services.pdf_service import PDFService


@pytest.fixture
def pdf_service():
    """Create PDFService instance"""
    return PDFService()


@pytest.fixture
def mock_valid_pdf_content():
    """Mock valid PDF content with text"""
    # Create a minimal valid PDF structure (just bytes for testing)
    # In real tests, you'd use a library or sample PDF
    return b"%PDF-1.4\nSample PDF content for testing\n%%EOF"


@pytest.fixture
def mock_large_pdf_content():
    """Mock PDF content exceeding 10MB limit"""
    # 11MB of data
    return b"x" * (11 * 1024 * 1024)


@pytest.fixture
def mock_extracted_text():
    """Mock extracted text from PDF"""
    return """
    Medical Emergency Drugs Protocol

    1. Epinephrine - Used for cardiac arrest and anaphylaxis
    2. Amiodarone - Antiarrhythmic medication
    3. Lidocaine - Local anesthetic and cardiac medication
    4. Atropine - Used for bradycardia

    Administration Guidelines:
    - Always check patient allergies
    - Verify correct dosage
    - Monitor vital signs
    """


@pytest.fixture
def mock_spanish_pdf_content():
    """Mock Spanish PDF content"""
    return """
    Protocolo de Medicamentos de Emergencia

    1. Epinefrina - Usado para paro cardíaco y anafilaxia
    2. Amiodarona - Medicamento antiarrítmico
    3. Lidocaína - Anestésico local y medicamento cardíaco
    4. Atropina - Usado para bradicardia

    Pautas de Administración:
    - Siempre verificar alergias del paciente
    - Verificar la dosis correcta
    - Monitorear signos vitales
    """


@pytest.fixture
def mock_claude_concepts():
    """Mock concepts extracted by Claude"""
    return [
        "Epinephrine - Used for cardiac arrest and anaphylaxis",
        "Amiodarone - Antiarrhythmic medication for irregular heartbeat",
        "Lidocaine - Local anesthetic and cardiac medication",
        "Atropine - Used for bradycardia (slow heart rate)",
        "Check patient allergies before administration",
        "Verify correct dosage for each medication",
        "Monitor vital signs during administration",
        "Emergency drug protocols must be followed",
        "Cardiac arrest requires immediate intervention",
        "Anaphylaxis is a life-threatening allergic reaction",
    ]


@pytest.fixture
def mock_claude_mnemonics():
    """Mock mnemonics generated by Claude"""
    return {
        "acrostic": {
            "title": "EALA Protocol",
            "content": "Every Advanced Learner Adapts: Epinephrine, Amiodarone, Lidocaine, Atropine",
            "how_to_use": "Remember EALA for emergency medications in order"
        },
        "story": {
            "title": "Emergency Room Journey",
            "content": "You rush into an ER and grab Epinephrine first, then Amiodarone, followed by Lidocaine, and finally Atropine",
            "how_to_use": "Visualize the journey through the ER collecting medications"
        },
        "visual": {
            "title": "Body Journey",
            "content": "Start at feet (Epinephrine), heart (Amiodarone), chest (Lidocaine), head (Atropine)",
            "how_to_use": "Associate each drug with a body part from bottom to top"
        }
    }


class TestPDFServiceInit:
    """Test PDF Service initialization"""

    def test_init_sets_constants(self, pdf_service):
        """Should initialize with correct constants"""
        assert pdf_service.MAX_FILE_SIZE_MB == 10
        assert pdf_service.MAX_PAGES == 50
        assert pdf_service.MIN_CONCEPTS == 10
        assert pdf_service.MAX_CONCEPTS == 50


class TestExtractTextFromPDF:
    """Test PDF text extraction"""

    @pytest.mark.asyncio
    async def test_extract_text_success(self, pdf_service, mock_extracted_text):
        """
        Scenario 1: Successful PDF text extraction
        Given I have a valid PDF file with extractable text
        When I call extract_text_from_pdf
        Then I receive the full extracted text
        """
        # Create mock PDF with pages
        mock_page1 = Mock()
        mock_page1.extract_text.return_value = "Medical Emergency Drugs Protocol\n\n1. Epinephrine"

        mock_page2 = Mock()
        mock_page2.extract_text.return_value = "2. Amiodarone\n3. Lidocaine"

        mock_pdf = Mock()
        mock_pdf.pages = [mock_page1, mock_page2]
        mock_pdf.__enter__ = Mock(return_value=mock_pdf)
        mock_pdf.__exit__ = Mock(return_value=False)

        pdf_content = b"valid pdf content"

        with patch("pdfplumber.open", return_value=mock_pdf):
            result = await pdf_service.extract_text_from_pdf(pdf_content)

        assert "Medical Emergency Drugs Protocol" in result
        assert "Epinephrine" in result
        assert "Amiodarone" in result
        assert "Lidocaine" in result
        assert "\n\n" in result  # Pages separated by double newline

    @pytest.mark.asyncio
    async def test_extract_text_file_too_large(self, pdf_service, mock_large_pdf_content):
        """
        Scenario 2: PDF file size validation (10MB limit)
        Given I have a PDF file larger than 10MB
        When I call extract_text_from_pdf
        Then I receive a ValueError with appropriate message
        """
        with pytest.raises(ValueError, match="PDF file is too large.*10MB"):
            await pdf_service.extract_text_from_pdf(mock_large_pdf_content)

    @pytest.mark.asyncio
    async def test_extract_text_too_many_pages(self, pdf_service):
        """
        Scenario 3: PDF page count validation (50 pages limit)
        Given I have a PDF file with more than 50 pages
        When I call extract_text_from_pdf
        Then I receive a ValueError with appropriate message
        """
        # Create mock PDF with 51 pages
        mock_pages = [Mock() for _ in range(51)]
        mock_pdf = Mock()
        mock_pdf.pages = mock_pages
        mock_pdf.__enter__ = Mock(return_value=mock_pdf)
        mock_pdf.__exit__ = Mock(return_value=False)

        pdf_content = b"valid pdf content"

        with patch("pdfplumber.open", return_value=mock_pdf):
            with pytest.raises(ValueError, match="PDF has too many pages.*50 pages"):
                await pdf_service.extract_text_from_pdf(pdf_content)

    @pytest.mark.asyncio
    async def test_extract_text_invalid_pdf(self, pdf_service):
        """
        Scenario 4: Invalid PDF handling
        Given I have an invalid or corrupted PDF file
        When I call extract_text_from_pdf
        Then I receive a ValueError with appropriate message
        """
        invalid_pdf_content = b"not a valid pdf"

        with patch("pdfplumber.open", side_effect=Exception("Invalid PDF")):
            with pytest.raises(ValueError, match="Failed to process PDF"):
                await pdf_service.extract_text_from_pdf(invalid_pdf_content)

    @pytest.mark.asyncio
    async def test_extract_text_empty_pdf(self, pdf_service):
        """
        Scenario 5: Empty/scanned PDF handling
        Given I have a PDF with no extractable text (scanned images)
        When I call extract_text_from_pdf
        Then I receive a ValueError indicating no text was extracted
        """
        # Create mock PDF with pages that return empty text
        mock_page = Mock()
        mock_page.extract_text.return_value = ""

        mock_pdf = Mock()
        mock_pdf.pages = [mock_page]
        mock_pdf.__enter__ = Mock(return_value=mock_pdf)
        mock_pdf.__exit__ = Mock(return_value=False)

        pdf_content = b"scanned pdf content"

        with patch("pdfplumber.open", return_value=mock_pdf):
            with pytest.raises(ValueError, match="Could not extract any text.*scanned or image-based"):
                await pdf_service.extract_text_from_pdf(pdf_content)

    @pytest.mark.asyncio
    async def test_extract_text_partial_empty_pages(self, pdf_service):
        """Should handle PDFs with some empty pages"""
        # Create mock PDF where some pages have text and others don't
        mock_page1 = Mock()
        mock_page1.extract_text.return_value = "Page 1 content"

        mock_page2 = Mock()
        mock_page2.extract_text.return_value = None  # Empty page

        mock_page3 = Mock()
        mock_page3.extract_text.return_value = "Page 3 content"

        mock_pdf = Mock()
        mock_pdf.pages = [mock_page1, mock_page2, mock_page3]
        mock_pdf.__enter__ = Mock(return_value=mock_pdf)
        mock_pdf.__exit__ = Mock(return_value=False)

        pdf_content = b"valid pdf content"

        with patch("pdfplumber.open", return_value=mock_pdf):
            result = await pdf_service.extract_text_from_pdf(pdf_content)

        assert "Page 1 content" in result
        assert "Page 3 content" in result
        # Only pages with text should be included


class TestProcessPDFForLearning:
    """Test complete PDF processing flow"""

    @pytest.mark.asyncio
    async def test_process_pdf_success(
        self,
        pdf_service,
        mock_extracted_text,
        mock_claude_concepts,
        mock_claude_mnemonics
    ):
        """
        Scenario 6: Process PDF for learning (integration with Claude)
        Given I have a valid PDF with educational content
        When I call process_pdf_for_learning
        Then I receive extracted concepts and generated mnemonics
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"valid pdf content"

        # Mock extract_text_from_pdf
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            return_value=mock_extracted_text
        ):
            # Mock Claude service methods
            with patch("app.services.pdf_service.claude_service") as mock_claude:
                mock_claude.extract_key_concepts = AsyncMock(return_value=mock_claude_concepts)
                mock_claude.generate_mnemonics = AsyncMock(return_value={
                    "acrostic": mock_claude_mnemonics["acrostic"],
                    "story": mock_claude_mnemonics["story"],
                    "visual": mock_claude_mnemonics["visual"],
                    "metadata": {
                        "generation_time_ms": 2500,
                        "item_count": 10,
                        "model": "claude-sonnet-4-20250514",
                        "user_id": user_id,
                        "deck_id": deck_id,
                    }
                })

                result = await pdf_service.process_pdf_for_learning(
                    file_content=pdf_content,
                    user_id=user_id,
                    deck_id=deck_id,
                )

        # Verify result structure
        assert "extracted_concepts" in result
        assert "concept_count" in result
        assert "mnemonics" in result
        assert "metadata" in result

        # Verify concepts
        assert result["extracted_concepts"] == mock_claude_concepts
        assert result["concept_count"] == len(mock_claude_concepts)

        # Verify mnemonics
        assert "acrostic" in result["mnemonics"]
        assert "story" in result["mnemonics"]
        assert "visual" in result["mnemonics"]

        # Verify metadata
        assert result["metadata"]["user_id"] == user_id
        assert result["metadata"]["deck_id"] == deck_id

    @pytest.mark.asyncio
    async def test_process_pdf_too_few_concepts(self, pdf_service, mock_extracted_text):
        """
        Should raise error if fewer than 3 concepts are extracted
        Given Claude extracts only 2 concepts from the PDF
        When I call process_pdf_for_learning
        Then I receive a ValueError indicating insufficient content
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"valid pdf content"

        # Mock extract_text_from_pdf
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            return_value=mock_extracted_text
        ):
            # Mock Claude service returning too few concepts
            with patch("app.services.pdf_service.claude_service") as mock_claude:
                mock_claude.extract_key_concepts = AsyncMock(return_value=["Concept 1", "Concept 2"])

                with pytest.raises(ValueError, match="Could not extract enough learning content"):
                    await pdf_service.process_pdf_for_learning(
                        file_content=pdf_content,
                        user_id=user_id,
                        deck_id=deck_id,
                    )

    @pytest.mark.asyncio
    async def test_process_pdf_limits_concepts_to_max(
        self,
        pdf_service,
        mock_extracted_text,
        mock_claude_mnemonics
    ):
        """
        Should limit concepts to MAX_CONCEPTS (50)
        Given Claude extracts 60 concepts from the PDF
        When I call process_pdf_for_learning
        Then I receive only the first 50 concepts
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"valid pdf content"

        # Create 60 mock concepts
        many_concepts = [f"Concept {i}" for i in range(60)]

        # Mock extract_text_from_pdf
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            return_value=mock_extracted_text
        ):
            # Mock Claude service methods
            with patch("app.services.pdf_service.claude_service") as mock_claude:
                mock_claude.extract_key_concepts = AsyncMock(return_value=many_concepts)
                mock_claude.generate_mnemonics = AsyncMock(return_value={
                    "acrostic": mock_claude_mnemonics["acrostic"],
                    "story": mock_claude_mnemonics["story"],
                    "visual": mock_claude_mnemonics["visual"],
                    "metadata": {
                        "generation_time_ms": 2500,
                        "item_count": 50,
                        "model": "claude-sonnet-4-20250514",
                        "user_id": user_id,
                        "deck_id": deck_id,
                    }
                })

                result = await pdf_service.process_pdf_for_learning(
                    file_content=pdf_content,
                    user_id=user_id,
                    deck_id=deck_id,
                )

        # Should be limited to 50
        assert len(result["extracted_concepts"]) == 50
        assert result["concept_count"] == 50

        # Verify Claude was called with limited concepts
        mock_claude.generate_mnemonics.assert_called_once()
        call_args = mock_claude.generate_mnemonics.call_args
        assert len(call_args.kwargs["list_items"]) == 50

    @pytest.mark.asyncio
    async def test_process_pdf_spanish_content(
        self,
        pdf_service,
        mock_spanish_pdf_content
    ):
        """
        Scenario 7: Multi-language PDF processing (Spanish)
        Given I have a PDF with Spanish content
        When I call process_pdf_for_learning
        Then Claude detects Spanish and generates Spanish mnemonics
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"valid spanish pdf content"

        spanish_concepts = [
            "Epinefrina - Usado para paro cardíaco",
            "Amiodarona - Medicamento antiarrítmico",
            "Lidocaína - Anestésico local",
        ]

        spanish_mnemonics = {
            "acrostic": {
                "title": "Protocolo EAL",
                "content": "Emergencia: Administra Lentamente - Epinefrina, Amiodarona, Lidocaína",
                "how_to_use": "Recuerda EAL para medicamentos de emergencia en orden"
            },
            "story": {
                "title": "Viaje por la Sala de Emergencias",
                "content": "Entras corriendo y agarras Epinefrina primero, luego Amiodarona, seguido de Lidocaína",
                "how_to_use": "Visualiza el viaje recogiendo medicamentos"
            },
            "visual": {
                "title": "Viaje por el Cuerpo",
                "content": "Comienza en los pies (Epinefrina), corazón (Amiodarona), pecho (Lidocaína)",
                "how_to_use": "Asocia cada medicamento con una parte del cuerpo"
            }
        }

        # Mock extract_text_from_pdf
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            return_value=mock_spanish_pdf_content
        ):
            # Mock Claude service methods
            with patch("app.services.pdf_service.claude_service") as mock_claude:
                mock_claude.extract_key_concepts = AsyncMock(return_value=spanish_concepts)
                mock_claude.generate_mnemonics = AsyncMock(return_value={
                    "acrostic": spanish_mnemonics["acrostic"],
                    "story": spanish_mnemonics["story"],
                    "visual": spanish_mnemonics["visual"],
                    "metadata": {
                        "generation_time_ms": 2500,
                        "item_count": 3,
                        "model": "claude-sonnet-4-20250514",
                        "user_id": user_id,
                        "deck_id": deck_id,
                    }
                })

                result = await pdf_service.process_pdf_for_learning(
                    file_content=pdf_content,
                    user_id=user_id,
                    deck_id=deck_id,
                )

        # Verify Spanish content is preserved
        assert "Epinefrina" in result["extracted_concepts"][0]
        assert "Amiodarona" in result["extracted_concepts"][1]
        assert "Lidocaína" in result["extracted_concepts"][2]

        # Verify Spanish mnemonics
        assert "Protocolo EAL" in result["mnemonics"]["acrostic"]["title"]
        assert "Emergencia" in result["mnemonics"]["acrostic"]["content"]

    @pytest.mark.asyncio
    async def test_process_pdf_extraction_error_propagates(self, pdf_service):
        """
        Should propagate extraction errors from extract_text_from_pdf
        Given extract_text_from_pdf raises a ValueError
        When I call process_pdf_for_learning
        Then the ValueError is propagated to the caller
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"invalid pdf content"

        # Mock extract_text_from_pdf to raise error
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            side_effect=ValueError("Could not extract text")
        ):
            with pytest.raises(ValueError, match="Could not extract text"):
                await pdf_service.process_pdf_for_learning(
                    file_content=pdf_content,
                    user_id=user_id,
                    deck_id=deck_id,
                )

    @pytest.mark.asyncio
    async def test_process_pdf_claude_error_propagates(
        self,
        pdf_service,
        mock_extracted_text
    ):
        """
        Should propagate Claude service errors
        Given Claude service fails during concept extraction
        When I call process_pdf_for_learning
        Then the error is propagated to the caller
        """
        user_id = "test-user-123"
        deck_id = "test-deck-456"
        pdf_content = b"valid pdf content"

        # Mock extract_text_from_pdf
        with patch.object(
            pdf_service,
            'extract_text_from_pdf',
            return_value=mock_extracted_text
        ):
            # Mock Claude service to raise error
            with patch("app.services.pdf_service.claude_service") as mock_claude:
                mock_claude.extract_key_concepts = AsyncMock(
                    side_effect=Exception("Claude API error")
                )

                with pytest.raises(Exception, match="Claude API error"):
                    await pdf_service.process_pdf_for_learning(
                        file_content=pdf_content,
                        user_id=user_id,
                        deck_id=deck_id,
                    )
